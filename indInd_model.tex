\documentclass{article}

\usepackage{proof}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{MnSymbol}
\usepackage{stmaryrd}

\usepackage{enumerate}
\usepackage{microtype}

\usepackage{color}

\usepackage{hyperref}

%\title{A set-theoretic model of induction-induction}
\title{A finite axiomatisation of inductive-inductive definitions}

\usepackage{authblk}
\author{Fredrik Nordvall Forsberg}
\author{Anton Setzer}
\affil{Swansea University \\
Singleton  Park \\
Swansea SA2 8PP, UK}

%\thanks{Supported by EPSRC grant EP/G033374/1, Theory and applications of induction-recursion.}}

\input macros.tex

\begin{document}

\maketitle

\begin{abstract}
  \noindent 
  Induction-induction is a principle for mutually defining data types
  $A : \Set$, $B : A \to \Set$. Both $A$ and $B$ are defined
  inductively, and the constructors for $A$ can refer to $B$ and vice
  versa. In addition, the constructor for $B$ can refer to \emph{the
    constructor} for $A$. Induction induction occurs in a natural way
  when formalising dependent type theory in type theory.  We give some
  examples of inductive-inductive definitions, such as the set of
  surreal numbers. We then give a new finite axiomatisation of the
  principle of induction-induction, and prove its consistency by
  constructing a model.
%Finally we analyse the relationship between induction-induction and indexed 
%inductive definitions.
\end{abstract}

\section{Introduction} %todo: rewrite introduction
\label{sec:introduction}

%Martin-L\"of Type Theory \cite{martinlof1984bibliopolis} is a
%foundational framework for constructive mathematics, where induction
%plays a major part in the construction of sets.

Induction is an important principle of definition and reasoning,
especially so in constructive mathematics.  Martin-L\"of's
formulation~\cite{martinlof1984bibliopolis} of type theory, for
instance, includes inductive definitions of among others Cartesian
products, disjoint unions, the natural numbers, lists, well-orderings,
the identity set, finite sets and a universe \`a la
Tarski~\cite{palmgren1998twentyfiveyears}.

These examples can be categorised as different kinds of inductive
definitions. The first few (up to well-orderings) are just ordinary inductive
definitions, where a single set is defined inductively. A typical
example is the type of well-orderings, parameterised by $A : \Set$, $B
: A \to \Set$:
\[
\infer{\Wsup(a, f) : W(A, B)}{a : A & \quad f : B(a) \to W(A, B)}
\]
Here $a : A$ is a \emph{non-inductive} argument, whereas $f : B(a) \to
W(A, B)$ is an \emph{inductive} argument because of the occurrence of
$W(A, B)$. Note how the later argument depends on the earlier
non-inductive argument.

The identity type and the finite sets are examples
%not of ordinary inductive definitions, but 
of inductive families~\cite{dybjer1994indfam}, where a family $X : I
\to \Set$ for some fixed index set $I$ is defined inductively
simultaneously. For the family $\Fin : \Nat \to \Set$ of finite sets,
the index set is $\Nat$:
\[
\infer{\finzero{n} : \Fin(n + 1)}{n : \Nat} \qquad
\infer{\finsucc{n}{m} : \Fin(n + 1)}{n : \Nat & \quad m : \Fin(n)}
\]
Each constructor constructs elements in $\Fin(k)$ for some $k : \Nat$,
and the type of the inductive argument $m : \Fin(n)$ has index $n$,
which is different from the index $n + 1$ of the type of the
constructed element. Thus the whole family has to be defined
simultaneously.

The universe \`a la Tarski is an example of an inductive-recursive
definition~\cite{dybjer2000IR}, where a set $U$ is defined inductively
together with a recursive function $T : U \to \Set$.  The constructors
for $U$ may depend negatively on $T$ applied to elements of $U$, as is
the case if $U$ for example is closed under dependent function spaces:
\[
\infer{\pi(a, b) : U}{a : U & \quad b : T(a) \to U}
\]
with $T(\pi(a, b)) = (x : T(a)) \to T(b(x))$.\footnote{The notation
  for the dependent function space and other type-theoretical
  constructs is explained in Section~\ref{sec:preliminaries}.}

Here, $T : U \to \Set$ is defined recursively. Sometimes, however, one
might not want to give $T(u)$ completely as soon as $u : U$ is
introduced, but instead define $T$ inductively as well. This is the
principle of \emph{induction-induction}. A set $A$ is inductively
defined simultaneously with an $A$-indexed set $B$, which is also
inductively defined, and the introduction rules for $A$ may also refer
to $B$. Typical introduction rules might take the form
\[ \infer{\text{intro}_A(a, b, \ldots) : A}{a : A &b : B(a) & \ldots} \quad
\infer{\text{intro}_B(a_0, b, a_1, \ldots) : B(a_1)}{a_0 : A &
&b : B(a_0) & a_1 : A & \ldots} \]

This is not a simple mutual inductive definition of two sets, as $B$
is indexed by $A$. It is not an ordinary inductive family, as $A$ may
refer to $B$. Finally, it is not an instance of induction-recursion,
as $B$ is constructed inductively, not recursively.

In this article, we give a new finite axiomatisation of a type theory
with inductive-inductive definitions. It differs from our earlier
axiomatisation~\cite{nordvallforsbergSetzer2010indind} in that it is
finite and hopefully easier to understand. The price we have to pay
for this simplicity is that the natural full function space
set-theoretical model construction becomes slightly more involved.

%Schemas and universes of descriptions.

%External schemas for general inductive sets and inductive families
%have been given by Backhouse et.\ al.\ \cite{backhouse1989diytt} %backhouse1988meaning
%and Dybjer \cite{dybjer1994indfam} respectively.

%this has been internalised by Dybjer and Setzer
%\cite{dybjersetzer1999finax,dybjersetzer2003inalg,dybjersetzer2006IIR}.

%Inductive-recursive
%definitions have also been used for generic programming in dependent
%type theory \cite{benke2003universes}.



\subsection{Examples of inductive-inductive definitions}
\label{sec:examples}

In this section, we give some examples of inductive-inductive
definitions, starting with the perhaps most important one:

\begin{example}[Contexts and types]
\label{ex:ctxt-type}

Danielsson \cite{danielsson2007formalisation} and Chapman
\cite{chapman2009eatitself} model the syntax of dependent type theory
in the theory itself by inductively defining contexts, types (in a
given context) and terms (of a given type). To see the
inductive-inductive nature of the construction, it is enough to
concentrate on contexts and types.

Informally, we have an empty context $\emptyCtxt$, and if we have any
context $\Gamma$ and a valid type $\sigma$ in that context, then we
can extend the context with a fresh variable $x : \sigma$ to get a new
context $\Gamma, x : \sigma$, and this is the only way contexts are
formed. We end up with the following inductive definition of the set
of contexts (with $\consCtxt{\Gamma}{\sigma}$ meaning $\Gamma, x :
\sigma$ since we are using de Bruijn indices):
\[
\infer{\emptyCtxt : \Ctxt}{} \qquad
\infer{\consCtxt{\Gamma}{\sigma} : \Ctxt}{\Gamma : \Ctxt & \sigma : \Ty(\Gamma)}
\]

Moving on to types, we have a base type $\baseTy{}$ (valid in any
context) and dependent function types: if $\sigma$ is a type in
context $\Gamma$, and $\tau$ is a type in $\Gamma, x : \sigma$ ($x$ is
the variable from the domain), then $\Pi(\sigma, \tau)$ is a type in
the original context. This leads us to the following inductive
definition of $\Ty : \Ctxt \to \Set$:
\[
\infer{\baseTy{\Gamma} : \Ty(\Gamma)}{\Gamma : \Ctxt} \qquad
\infer{\piTy{\Gamma}{\sigma}{\tau} : \Ty(\Gamma)}{\Gamma : \Ctxt
                    & \sigma : \Ty(\Gamma)
                    & \tau : \Ty(\consCtxt{\Gamma}{\sigma})}
\]

Note that the definition of $\Ctxt$ refers to $\Ty$, so both sets have
to be defined simultaneously. Note also how the introduction rule for
$\Pi$ explicitly focuses on a specific constructor in the index of the
type of $\tau$. 
\blackqed
\end{example}

Often, one wishes to define a set $A$ where all elements of $A$
satisfy some property $P : A \to \Set$. If $P$ is inductively defined,
one can define $A$ and $P$ simultaneously and achieve that every
element of $A$ satisfies $P$ by construction. One example of such a
data type is the type of sorted lists:

\begin{example}[Sorted lists]
\label{ex:sorted-list}

Let us define a data type consisting of sorted lists (of natural
numbers, say). With induction-induction, we can simultaneously define
the set $\SortedList$ of sorted lists and the predicate $\lessList :
(\Nat \times \SortedList) \to \Set$ with $n \lessList \ell$ true if
$n$ is less than or equal to every element of $\ell$.

The empty list is certainly sorted, and if we have a proof $p$ that
$n$ is less than or equal to every element of the list $\ell$, we can
put $n$ in front of $\ell$ to get a new sorted list
$\consList{n}{\ell}{p}$. Translated into introduction rules, this becomes:
\[
\infer{\nilList : \SortedList}{} \qquad
\infer{\consList{n}{\ell}{p} : \SortedList}{n : \Nat \quad & \ell : \SortedList \quad & p : n \lessList \ell}
\]
For $\lessList$, we have that every $m : \Nat$ is trivially smaller
than every element of the empty list, and if $m \leq n$ and
inductively $m \lessList \ell$, then $m \lessList \consList{n}{\ell}{p}$:
\[
\infer{\nilLess{m} : m \lessList \nilList}
%{m : \Nat}
{} \qquad
\infer{\consLess{n}{\ell}{p}{m}{q}{p_{m, \ell}}\ : m \lessList \consList{n}{\ell}{p}}
%      {m, n : \Nat \quad & \ell : \SortedList \quad & p : n \lessList \ell \quad &
       {q : m \leq n \quad & p_{m, \ell} : m \lessList \ell}
\]
This makes sense even if the order $\leq$ is not transitive. If it is
(as the standard order on the natural numbers, for example), the
argument $p_{m, \ell} : m \lessList \ell$ can be dropped from the
constructor $\consLessbare$, since we already have $q : m \leq n$ and
$p : n \lessList \ell$, hence by transitivity we must have $m
\lessList \ell$.

 Of course, there are also many alternative ways to define such a data type
 using ordinary induction.
%, but the inductive-inductive one seems
% natural and might be more convenient for some purposes.
\blackqed
\end{example}

\begin{example}[Conway's surreal numbers]
\label{ex:surreal}

Conway \cite{conway2001ONAG} informally uses induction-induction (but
couched in ZF set theory, not type theory) in order to define his
\emph{surreal numbers}. The ``set''\footnote{There are some size
  issues, since the surreal numbers contain the class of ordinals.} of
surreal numbers is defined inductively, together with an order
relation on surreal numbers which is also defined inductively:

\begin{itemize}
\item A surreal number $X = (X_\mathrm{L}, X_\mathrm{R})$ consists of
  two sets $X_\mathrm{L}$ and $X_\mathrm{R}$ of surreal numbers, such
  that no element from $X_\mathrm{L}$ is greater than any element from
  $X_\mathrm{R}$.
\item A surreal number $Y = (Y_\mathrm{L}, Y_\mathrm{R})$ is greater
  than another surreal number $X = (X_\mathrm{L}, X_\mathrm{R})$, $X \leq Y$, if and
  only if
  \begin{itemize}
  \item there is no $x \in X_\mathrm{L}$ such that $Y \leq x$, and
  \item there is no $y \in Y_\mathrm{R}$ such that $y \leq X$.
  \end{itemize}
\end{itemize}

Both rules can be understood as inductive definitions. However, they
are not formulated with a constructive reading in mind (too many
negations!). Mamane~\cite{mamane2004surrealCoq} develops the theory of
surreal numbers in the proof assistant Coq. %todo: expand
\blackqed
\end{example}


\subsection{Inductive-inductive definitions versus inductive-recursive definitions}
\label{sec:indind-vs-IR}

%todo: rewrite

In both an inductive-inductive and an inductive-recursive definition,
a set $U$ and a family $T : U \to \Set$ are defined
simultaneously. The difference between the two principles lies in how
$T$ is defined. In an inductive-inductive definition, $T$ is generated
inductively, i.e.\ given by a constructor $\intro{T} : (x : F(U, T))
\to T(i(x))$ for some (strictly positive) functor
$F$. %todo: mention i : F(U, T) \to U?
In an inductive-recursive definition, on the other hand, $T$ is
defined by recursion on the way the elements of $U$ are
generated. This means that $T(\intro{U}(x))$ must be given completely
as soon as the constructor $\intro{U} : G(U, T) \to U$ is
introduced. In an inductive-inductive definition, many different
constructors for $T$ can contribute to the set $T(\intro{U}(x))$.
However, because of the inductive generation of $T$, $T$ can only
occur positively in the type of the constructors for $U$ (and $T$),
whereas $T$ can occur also negatively in an inductive-recursive
definition.

\section{Type-theoretical preliminaries}
\label{sec:preliminaries}

We work in a type theory with at least two universes $\Set$ and
$\TYPE$, with $\Set : \TYPE$ and $\Set$ a subuniverse of $\TYPE$,
i.e.\ if $A : \Set$ then $A : \TYPE$. Both $\Set$ and $\TYPE$ are
closed under dependent function types, written $(x : A) \to B$, where
$B$ is a set or type depending on $x: A$. Abstraction is written as
$\lambda x : A . e$, where $e : B$ depending on $x : A$, and
application as $f(x)$. Repeated abstraction and application are
written as $\lambda x_1 : A_1 \ldots x_k : A_k . e$ and $f(x_1,
\ldots, x_k)$. If the type of $x$ can be inferred, we simply write
$\lambda x.e$ as an abbreviation.  Furthermore, both $\Set$ and
$\TYPE$ are closed under dependent products, written $(x : A) \times
B$, where $B$ is a set or type depending on $x: A$, with pairs
$\langle a , b \rangle$, where $a : A$ and $b : B[x \coloneqq a]$.
% and projections $\pi_1$, $\pi_2$
We also have $\beta$- and $\eta$-rules for both dependent function types
and products.

We need an empty type $\zero : \Set$, with elimination ${!_A : \zero
  \to A}$ for every $A : \Set$. We need a unit type $\one : \Set$,
with unique element $\oneelt : \one$ and an $\eta$-rule stating that
if $x : \one$, then $x = \oneelt : \one$. Moreover, we include a two
element set $\two : \Set$, with elements $\twott : \two$, $\twoff :
\two$ and elimination constant $\IF~\cdot~\THEN~\cdot~\ELSE~\cdot :$
$(a : \two) \to A(\twott) \to A(\twoff) \to A(a)$ where $i : \two
\Rightarrow A(i) : \TYPE$. I should satisfy the obvious computation
rules, i.e.\ $\IF~\twott~\THEN~a~\ELSE~b = a$ and
$\IF~\twoff~\THEN~a~\ELSE~b = b$.
%Finally, we require the type $\Nat$ of natural numbers.

With $\IF~\cdot~\THEN~\cdot~\ELSE~\cdot$ and dependent products, we can now
% as in \cite[A.2]{dybjersetzer2006IIR}
define the disjoint union of two sets $A + B \coloneqq$ ${(x : \two)}
\times (\IF~x~\THEN~A~\ELSE~B)$ with constructors $\inl = \lambda {a :
  A} . \langle \twott , a \rangle$ and $\inr = \lambda {b : B}
. \langle \twoff , b \rangle$, and prove the usual formation,
introduction, elimination and equality rules. Importantly, we get
large elimination for sums, since we have large elimination for
$\two$. We write the eliminator $[f, g] : {(c : A + B)} \to C(c)$, where
$i : A + B \Rightarrow A(i) : \TYPE$ and $f : (a : A) \to C(\inl(a))$,
$g : (b : B) \to C(\inr(b))$. The equality rules are
\begin{align*}
[f, g](\inl(a)) &= f(a) \enspace , \\
[f, g](\inr(b)) &= g(b) \enspace .
\end{align*}
%We write $\bigplus_{k = 0}^n A_k$ for the iterated sum $A_0 + (A_1 +
%(\ldots + A_n)\cdots)$ and $[f_0, f_1, \ldots, f_n]$ for the iterated
%case distinction $[f_0, [f_1, [\ldots , f_n]]\cdots]$.

Intensional type theory in Martin-L\"of's logical framework extended with
dependent products and $\zero$, $\one$, $\two$
%and $\Nat$
 has all the features we
need. Thus, our development can be seen as an extension of
the logical framework.

\section{A finite axiomatisation}
\label{sec:axiomatisation}
 
%TODO: rewrite

In this section, we give a finite axiomatisation of a type theory with
inductive-inductive definitions. This axiomatisation differs slightly
from our previous
axiomatisation~\cite{nordvallforsbergSetzer2010indind}, in that it
hopefully is easier to understand. However, the definable sets should
be the same for both axiomatisations.

%TODO: rewrite

We take inspiration from Dybjer and Setzer's axiomatisation of
inductive-recursive definitions~\cite{dybjersetzer1999finax}. The main
idea is to construct a universe consisting of codes for
inductive-inductive definitions, together with a decoding function,
which maps a code $\varphi$ to the domain of the constructor for the
inductively defined set represented by $\varphi$.  Just as the second
component $B : A \to \Set$ depends on the first set $A$, the universe $\SPBp : \SPAp \to \TYPE$
of codes for the second component will depend on the universe $\SPAp$ of codes
for the first set.

\subsection{Dissecting an inductive-inductive definition}
\label{sec:dissect-ind}

We wish to formalise and internalise an inductive-inductive definition
given by constructors
\[
\introA : \Phi_{\mathrm{A}}(A, B) \to A
\]
and
\[
\introB : (x : \Phi_{\mathrm{B}}(A, B, \introA)) \to B(\theta(x))
\]
for some $\Phi_{\mathrm{A}}(A, B) : \Set$, $\Phi_{\mathrm{B}}(A, B,
\introA) : \Set$ and $\theta : \Phi_{\mathrm{B}}(A, B, \introA) \to
A$.
Here, $\theta(x)$ is the \emph{index} of $\introB(x)$, i.e.\ the element $a :
A$ such that $\introB(x) : B(a)$.

Not all expressions $\Phi_{\mathrm{A}}$ and $\Phi_{\mathrm{B}}$ give
rise to acceptable inductive-inductive definitions. It is well known,
for example, that the theory becomes inconsistent if $A$ or $B$ occur
in negative positions in $\Phi_{\mathrm{A}}$ or $\Phi_{\mathrm{B}}$
respectively. Thus, we restrict our attention to a class of strictly
positive functors.

These are based on the following analysis of what kind of premises
that can occur in a definition. A premise is either \emph{inductive}
or \emph{non-inductive}. A non-inductive premise consists of a
previously constructed set $K$, which later premises can depend on. An
inductive premise is inductive in $A$ or $B$. If it is inductive in
$A$, it is of the form $(K \to A)$ for some previously constructed set
$K$%
%(this is also called a \emph{generalized} inductive premise, with
%the special case $K = \one$ being called an \emph{ordinary} inductive
%premise)
. Premises inductive in $B$ are of the form $((x : K) \to
B(i(x))$ for some $i : K \to A$. In the case of an ordinary inductive
premise, $K = \one$ so that $i : \one \to A$ just amounts to a choice
of an index $a = i(\oneelt)$ such that the inductive argument comes
from $B(a)$.

%todo: improve

\subsection{The axiomatisation}
\label{sec:formal-axiomatisation}

We now give the formal rules for an inductive-inductive definition of
$A : \Set$, $B : A \to \Set$. These consists of a set of rules for the
universe $\SPAp$ of descriptions of the set $A$ and its decoding
function $\ArgAp$, a set of rules for the universe $\SPBp$ and its
decoding function $\ArgBp$, and formation and introduction rules for
each pair of codes $\gammaA : \SPAp$, $\gammaB : \SPBp(\gammaA)$.

\subsubsection{The universe $\SPAp$ of descriptions of $A$}
\label{sec:SPA}
  
We introduce the universe of codes for the index set with the
formation rule
\[
\infer{\SPA(\Aref) : \TYPE}{\Aref : \Set}
\]
The set $\Aref$ should be thought of as the elements of $A$ that we
can refer to in the code that we are defining. To start with, we
cannot refer to any elements in $A$, and so we define $\SPAp \coloneqq
\SPA(\zero)$. After introducing an inductive argument $a : A$, we can
refer to $a$ in later arguments, so that $\Aref$ will be extended to
include $a$ as well for the construction of the rest of the code.

The introduction rules for $\SPA$ reflects the informal discussion in
Section~\ref{sec:dissect-ind}. The rules are as follows (we suppress
the global premise $\Aref : \Set$):
\[
\infer{\nilA : \SPA(\Aref)}{}
\]
%
The code $\nilA$ represents a trivial constructor $c : \one \to A$ (a base case).
%
\[
\infer{\nonindA(K, \gamma) : \SPA(\Aref)}{K : \Set & \quad \gamma : K \to \SPA(\Aref)}
\]
%
The code $\nonindA(K, \gamma)$ represents a non-inductive argument $x
: K$, with the rest of the arguments given by $\gamma(x)$.
%
\[
\infer{\AindA(K, \gamma) : \SPA(\Aref)}{K : \Set & \quad \gamma : \SPA(\Aref + K)}
\]
%
The code $\AindA(K, \gamma)$ represents an inductive argument with
type $K \to A$, with the rest of the arguments given by
$\gamma$. Notice that $\gamma : \SPA(\Aref + K)$, so that the
remaining arguments can refer to more elements in $A$ (namely those
introduced by the inductive argument).
%
\[
\infer{\BindA(K, \hindex, \gamma) : \SPA(\Aref)}{K : \Set & \quad \hindex : K \to \Aref & \quad \gamma : \SPA(\Aref)}
\]
%
Finally, the code $\BindA(K, \hindex, \gamma)$ represents an inductive
argument with type $(x : K) \to B(i(x))$, where the index $i(x)$ is
determined by $\hindex$, and the rest of the arguments are given by
$\gamma$.
%

\begin{example}
  The constructor $\consCtxtbare : ((\Gamma : \Ctxt) \times \Ty(\Gamma))
  \to \Ctxt$ is represented by the code
\[
\gamma_{\consCtxtbare} = \AindA(\one, \BindA(\one, \lambda (\oneelt : \one)\,.\,\widehat{\Gamma}, \nilA)) \enspace ,
\]
where $\widehat{\Gamma} = \inr(\oneelt)$ is the representation of $\Gamma$ in $\Aref = \zero + \one$.
\blackqed
\end{example}

We now define the decoding function $\ArgA$, which maps a code to the
domain of the constructor it represents. In addition to a set $\Xref$
and a code $\gamma : \SPA(\Xref)$, $\ArgA$ will take a set $\A$ and a
family $\B : \A \to \Set$ as arguments to use as $A$ and $B$ in the
inductive arguments. These will later be instantiated recursively. We
also require a function $\repA : \Xref \to \A$ which we think of as
mapping a ``referable'' element to the element it represents in
$\A$. All in all, $\ArgA$ has the following formation rule:
%
\[
\infer{\ArgA(\Xref, \gamma, \A, \B, \repA) : \Set}{\Xref : \Set
                                         & \quad \gamma : \SPA(\Xref)
                                         & \quad \A : \Set
                                         & \quad \B : \A \to \Set
                                         & \quad \repA : \Xref \to \A}
\]
%
Notice that if $\gamma : \SPAp$, i.e.\ if $\Xref = \zero$, then we can
choose $\repA = {} \magic{X} : \zero \to \A$ (indeed, extensionally,
this is the only choice), so that we can define
\[
\ArgAp : \SPAp \to (\A : \Set) \to (\B : \A \to \Set) \to \Set
\]
by $\ArgAp(\gamma, \A, \B) = \ArgA(\zero, \gamma, \A, \B, \magic{X})$.

The definition of $\ArgA$ follows the informal description of what the
different codes represent above:

%todo: formatting %todo mark changing arguments
\begin{align*} 
  \ArgA(\Xref, \nilA, \A, \B, \repA) &= \one \\
  \ArgA(\Xref, \nonindA(K, \gamma), \A, \B, \repA) &= (x : K) \times \ArgA(\Xref, \gamma(x), \A, \B, \repA) \\
  \ArgA(\Xref, \AindA(K, \gamma), \A, \B, \repA) &=  (j : K \to \A) \times \ArgA(\Xref + K, \gamma, \A, \B, [\repA, j]) \\
  \ArgA(\Xref, \BindA(K, \hindex, \gamma), \A, \B, \repA) &=  ((x : K) \to \B((\repA \circ \hindex)(x))) \times \ArgA(\Xref, \gamma, \A, \B, \repA) \\
\end{align*}

\begin{example}
  Recall the code $\gamma_{\consCtxtbare} = \AindA(\one, \BindA(\one,
  \lambda (\oneelt : \one)\,.\,\inr(\oneelt), \nilA))$ for the
  constructor $\consCtxtbare : ((\Gamma : \Ctxt) \times \Ty(\Gamma)) \to
  \Ctxt$. We have 
\[
\ArgAp(\gamma_{\consCtxtbare}, \Ctxt, \Ty) = (\Gamma : \one \to \Ctxt)
\times (\one \to \Ty(\Gamma(\oneelt))) \times \one
\]
which, thanks to the $\eta$-rules for $\one$, is isomorphic to the
domain of $\consCtxtbare$. 
\blackqed
\end{example}

\subsubsection{Towards descriptions of $B$} %todo: rename
\label{sec:towards-SPB}

As we have seen in Example \ref{ex:ctxt-type}, it is important that
the constructor $\introB$ for the second set $B : A \to \Set$ can
refer to the constructor $\introA$ for the first set $A$. This means
that inductive arguments might be of type $B(\introA(\overline{a}))$
for some $\overline{a} : \ArgAp(\gammaA, A, B)$ or even
$B(\introA(\ldots\introA\ldots(\overline{a})))$ for some $\overline{a}
: \ArgAp(\gammaA, \ldots \ArgAp(\gammaA, A, B)\ldots, B')$. Thus, we
need to be able to represent such indices in the descriptions of the
constructor $\introB$.

First, it is no longer enough to only keep track of the referable
elements $\Xref$ of $\A$ -- we need to be able to refer to elements of
$B$ as well, since they could be used as arguments to $\introA$. We
will represent the elements of $\B$ we can refer to by a set $\Yref$,
together with functions $\repIndex : \Yref \to \A$ and $\repB : (x :
\Yref) \to \B(\repIndex(x))$ ; the function $\repIndex$ gives the index
of the represented element, and $\repB$ the actual element.

We want to represent elements in $\ArgAp(\gammaA, \A, \B)$. We claim that
the elements in $\ArgAp(\gammaA, \Xref + \Yref, [\lambda x\,.\,\zero,
\lambda x\,.\,\one])$ are suitable for this purpose. To see this,
first observe that we can define a functions
\[
f : \Xref + \Yref \to \A
\]
%
%and
%
\[
g : (x : \Xref + \Yref) \to
    [\lambda x\,.\,\zero, \lambda x\,.\,\one](x)
      \to \B(f(x))
\]
%
by $f = [\repA, \repIndex]$ and $g = [\lambda x\,.\,\magic{\B \circ
  \repA}, \lambda x \oneelt\,.\, \repB(x)]$. Then, we can lift these
functions to a function
%
\[
\ArgAp(\gammaA, f, g) : \ArgAp(\gammaA, \Xref +\Yref, [\lambda x\,.\,\zero, \lambda x\,.\,\one]) \to
                       \ArgAp(\gammaA, \A, \B)
\]
%
by observing that $\ArgAp(\gammaA)$ is functorial:

\begin{lemma} %todo: reword. Do we want to avoid cat. theory?
  For each $\gamma : \SPAp$, $\ArgAp(\gamma)$ extends to a functor from
  families of sets to sets, i.e.\ given $f : \A \to \A'$ and $g : (x :
  \A) \to \B(x) \to \B'(f(x))$, one can define $\ArgAp(\gamma, f, g) :
  \ArgAp(\gamma, \A, \B) \to \ArgAp(\gamma, \A', \B')$ such that identities
  and compositions are preserved.
\end{lemma}
\begin{proof}
  This is straightforward in extensional type theory. In intensional
  type theory, we have to be more careful. The function $\ArgA(\gamma,
  f, g)$ is defined by induction over $\gamma$%
% and $\Xref$ % why did I write this??
: let $\A$,
  $\B$, $\repA : \Xref \to \A$, $\A'$, $\B'$, $\repA' : \Xref \to \A'$ and
  $f : \A \to \A'$, $g : (x : \A) \to \B(x) \to \B'(f(x))$ be given. In
  addition, assume that $f(\repA(x)) = \repA'(x)$ for all $x :
  \Xref$. It is enough for our purposes to state this in a
  ``specialised Leibniz form''; we require a term
  \[
  p : (x : \Xref) \to \B'(f(\repA(x))) \to \B'(\repA'(x)) \enspace .
  \]
  % 
  Thus we define
  % 
  \[
  \ArgA(\gamma, f, g, p) : %(p : (x : \Xref) \to \B'(f(\repA(x))) \to \B'(\repA'(x))) \to
  \ArgA(\Xref, \gamma, \A, \B, \repA)
  \to \ArgA(\Xref, \gamma, \A', \B', \repA')
  \]
  % 
  by induction over $\gamma$:
  \begin{align*}
    \ArgA(\nilA, f, g, p, \oneelt) &= \oneelt\\
    \ArgA(\nonindA(K, \gamma), f, g, p, \pair{k}{y}) &= \pair{k}{\ArgA(\gamma(k), f, g, p, y)}\\
    \ArgA(\AindA(K, \gamma), f, g, p, \pair{j}{y}) &= \pair{f \circ j}{\ArgA(\gamma, f, g, [p, \lambda x\,.\,\id], y)}\\
    \ArgA(\BindA(K, \hindex, \gamma), f, g, p, \pair{j}{y}) &= \pair{\lambda k\,.\,p(\hindex(k), g(\repA(\hindex(k)), j(k)))}{\ArgA(\gamma, f, g, p, y)}
  \end{align*}
  
  Finally, we can define $\ArgAp(\gamma, f, g) : \ArgAp(\gamma, A, B) \to
  \ArgAp(\gamma, A', B')$ by
  \[
  \ArgAp(\gamma, f, g) \coloneqq \ArgA(\gamma,f, g, \magic{B'(f(\repA(x))) \to B'(\repA'(x))}) \enspace .
  \]
  % 
  (Pointwise) preservation of identities and composition is easily checked.
\end{proof}

Recall that we want to use the lemma to represent elements in
$\ArgAp(\gammaA, \A, \B)$ by elements in $\ArgAp(\gammaA, \Xref +\Yref,
[\lambda x\,.\,\zero, \lambda x\,.\,\one])$. We can actually do one
better, and represent arbitrarily terms built from elements in $\A$ and
$\B$ with the use of a constructor $\introA : \ArgAp(\gammaA, \A, \B) \to
\A$. For this, define the set $\Aterm(\gammaA, \Xref, \Yref)$ of terms
``built from $\introA$, $\Xref$ and $\Yref$'' with introduction rules
%
\[
\infer{\termAref(x) : \Aterm(\gammaA, \Xref, \Yref)}{x : \Xref}
\]
%
%
\[
\infer{\termBref(x) : \Aterm(\gammaA, \Xref, \Yref)}{x : \Yref}
\]
%
%
\[
\infer{\termArg(x) : \Aterm(\gammaA, \Xref, \Yref)}{x : \ArgAp(\gammaA, \Aterm(\gammaA, \Xref, \Yref), \Bterm(\gammaA, \Xref, \Yref))}
\]
Here, $\Bterm(\gammaA, \Xref, \Yref) : \Aterm(\gammaA, \Xref, \Yref) \to \Set$ is defined by
\[
\begin{tabular}{lcr}
$\Bterm(\gammaA, \Xref, \Yref, \termAref(x))$ & $=$ & $\zero$ \\
$\Bterm(\gammaA, \Xref, \Yref, \termBref(x))$ & $=$ & $\one$  \\
$\Bterm(\gammaA, \Xref, \Yref, \termArg(x))$  & $=$ & $\zero$
\end{tabular}
\]
Note that this is formally an inductive-recursive definition.
The intuition behind the definition of $\Bterm$ is that all elements of
$\B$ we know are represented in $\Yref$, and only in $\Yref$. 

All elements in $\Aterm(\gammaA,\Xref, \Yref)$ represents elements in
$\A$, given that we have a function $\introA : \ArgAp(\gammaA, \A, \B) \to
\A$ and the elements of $\Xref$ and $\Yref$ represents elements of $\A$
and $\B$ respectively (i.e.\ we have $\repA : \Xref \to \A$, $\repIndex
: \Yref \to \A$ and $\repB : (x : \Yref) \to \B(\repIndex(x))$).
Formally, we can simultaneously define the following two functions:
%
\[ %\ldots = \gammaA, \introA, \repA, \repIndex, \repB
\infer{\deduce{\repBbar(\ldots) : (x : \Aterm(\gammaA, \Xref, \Yref)) \to \Bterm(\gammaA, \Xref, \Yref, x) \to \B(\repAbar(\ldots, x))}
              {\repAbar(\ldots) : \Aterm(\gammaA, \Xref, \Yref) \to \A}}
      {\gammaA : \SPAp & \quad
       \introA : \ArgAp(\gammaA, \A, \B) \to \A & \quad
              %{\deduce{\B : \A \to \Set}
              %        {\A : \Set}} & \quad
       \deduce{\repB : (x : \Yref) \to \B(\repIndex(x))}
              {\deduce{\repIndex : \Yref \to \A}
                      {\repA : \Xref \to \A}}}
\]
%
The definition of $\repAbar$ is straightforward. The interesting case
is $\termArg(x)$, where we make use of the constructor $\introA$, the
functoriality of $\ArgAp$ and the mutually defined $\repBbar$:
\begin{align*}
  \repAbar(\gammaA, \introA, \repA, \repIndex, \repB, \termAref(x)) &= \repA(x) \\
  \repAbar(\gammaA, \introA, \repA, \repIndex, \repB, \termBref(x)) &= \repIndex(x) \\
  \repAbar(\gammaA, \introA, \repA, \repIndex, \repB, \termArg(x)) 
    &= \introA(\ArgAp(\gammaA, \repAbar(\ldots), \repBbar(\ldots), x))
\end{align*}
%
The simultaneously defined $\repBbar$ is very simple:
%
\begin{align*}
  \repBbar(\gammaA, \introA, \repA, \repIndex, \repB, \termAref(x), y) &= \magic{\B \circ \repAbar(\ldots)}(y) \\
\repBbar(\gammaA, \introA, \repA, \repIndex, \repB, \termBref(x), \oneelt) &= \repB(y) \\
\repBbar(\gammaA, \introA, \repA, \repIndex, \repB, \termArg(x), y) &= \magic{\B \circ \repAbar(\ldots)}(y) \\ \\
\end{align*}

\begin{example}
  What are some terms in $\Aterm(\gamma_{\consCtxtbare}, \Xref, \Yref)$, where
  \[
  \gamma_{\consCtxtbare} = \AindA(\one, \BindA(\one,
  \lambda (\oneelt : \one)\,.\,\inr(\oneelt), \nilA))
  \]
  is the code for the constructor
  \[
  \consCtxtbare : \big((\Gamma : \one \to A) \times (\one \to B(\Gamma(\oneelt))) \times \one\big) \to A \enspace ?
  \]
  Suppose that we have $\hat{a} : \Xref$ with $\repA(\hat{a}) = a : A$
  and $\hat{b} : \Yref$ with $\repIndex(\hat{b}) = a$ and
  $\repB(\hat{b}) = b : B(a)$. We then have 
  \begin{itemize}
  \item $\termAref(\hat{a}) : \Aterm(\gamma_{\consCtxtbare}, \Xref, \Yref)$ with
  $\repAbar(\gamma_{\consCtxtbare}, \consCtxtbare, \ldots, \hat{a}) =
  a$ (so elements from $\Xref$ are terms),
\item $\termBref(\hat{b}) :  \Aterm(\gamma_{\consCtxtbare}, \Xref, \Yref)$ with
  $\repAbar(\gamma_{\consCtxtbare}, \consCtxtbare, \ldots,
  \termBref(\hat{b})) = a$ (so elements from $\Yref$ are terms,
  representing the index of the element in $B$ they represent), and
\item  $\widehat{a,b} \coloneqq \termArg(\langle (\lambda \oneelt.\,\termBref(\hat{b})) ,
  \langle (\lambda \oneelt.\,\oneelt), \oneelt\rangle\rangle) :
  \Aterm(\gamma_{\consCtxtbare}, \Xref, \Yref)$ with
  \[
      \repAbar(\gamma_{\consCtxtbare}, \consCtxtbare, \ldots, \widehat{a,b})
    = \consCtxt{(\repIndex(\hat{b}))}{(\repB(\hat{b}))} 
    = \consCtxt{a}{b} \enspace .
  \]
% (λ _ → arg  (ff , ((λ _ → bref (inr _)) , ((λ _ → _) , _))))
\blackqed
\end{itemize}
\end{example}

\subsubsection{The universe $\SPBp$ of descriptions of $B$}
\label{sec:SPB}

We now introduce the universe $\SPB$ of descriptions
for $B$. It has formation rule
%
\[
\infer{\SPB(\Aref, \Bref, \gammaA) : \TYPE}{\Aref, \Bref : \Set & \quad \gammaA : \SPAp}
\]
%
Again, we are interested in codes which initially do not refer to
any elements and define $\SPBp : \SPAp \to \TYPE$ by $\SPBp(\gammaA)
\coloneqq \SPB(\zero, \zero, \gammaA)$.

The introduction rules for $\SPB$ are similar to the ones for $\SPA$,
except we now need to specify an index for the codomain of the
constructor, and indices for arguments inductive in $B$ can be
arbitrary terms built up from $\introA$ and elements we can refer to.

\[
\infer{\nilB(a) : \SPB(\Aref, \Bref, \gammaA)}{a : \Aterm(\gammaA, \Aref, \Bref)}
\]
%
%The code $\nilA$ represents a trivial constructor $c : \one \to A$ (a base case).
%
\[
\infer{\nonindB(K, \gamma) : \SPB(\Aref, \Bref, \gammaA))}{K : \Set & \quad \gamma : K \to \SPB(\Aref, \Bref, \gammaA)}
\]
%
%The code $\nonindA(K, \gamma)$ represents a non-inductive argument $x: K$, with the rest of the arguments given by $\gamma(x)$.
%
\[
\infer{\AindB(K, \gamma) : \SPB(\Aref, \Bref, \gammaA)}{K : \Set & \quad \gamma : \SPB(\Aref + K, \Bref, \gammaA)}
\]
%
%The code $\AindA(K, \gamma)$ represents an inductive argument with
%type $K \to A$, with the rest of the arguments given by
%$\gamma$. Notice that $\gamma : \SPA(\Aref + K)$, so that the
%remaining arguments can refer to more elements in $A$ (namely those
%introduced by the inductive argument).
%
\[
\infer{\BindB(K, \hindex, \gamma) : \SPB(\Aref, \Bref, \gammaA)}{K : \Set & \quad \hindex : K \to \Aterm(\Aref, \Bref, \gammaA) & \quad \gamma : \SPB(\Aref, \Bref + K, \gammaA)}
\]
%
%Finally, the code $\BindA(K, \hindex, \gamma)$ represents an inductive
%argument with type $(x : K) \to B(i(x))$, where the index $i(x)$ is
%determined by $\hindex$, and the rest of the arguments are given by
%$\gamma$.
%
\begin{example}
  The constructor
  % 
  \[
  \Pi : \big((\Gamma : \Ctxt) \times (\sigma : \Ty(\Gamma)) \times \Ty(\consCtxt{\Gamma}{\sigma})\big)\to \Ty(\Gamma)
  \]
  % 
  is represented by the code
  % 
  \[
  \gamma_{\Pi} = \AindB(\one,
                  \BindB(\one, \lambda \oneelt\,.\,\widehat{\Gamma}, 
                    \BindB(\one, \lambda \oneelt\,.\,\widehat{\text{in}\pair{\Gamma}{\sigma}},
                      \nilB(\widehat{\Gamma}))))
  \]
  %
  where $\widehat{\Gamma} = \pair{0}{\inr(\oneelt)}$ is the element
  representing the first argument $\Gamma : \Ctxt$ and
  $\widehat{\text{in}\pair{\Gamma}{\sigma}} =
  \pair{1}{\pair{\twott}{\pair{(\lambda
        \oneelt\,.\,\inr(\inr(\oneelt)))}{\pair{(\lambda
          \oneelt\,.\,\oneelt)}{\oneelt}}}}$ is the element
  representing $\consCtxt{\Gamma}{\sigma}$ (the number $1$ corresponds
  to the fact that we are using one nesting of constructors).
\blackqed
\end{example}

The definition of $\ArgB$ should now not come as a surprise. First, we have a formation rule:
%
\[
\mathclap{%
\infer{\ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \gamma) : \Set}
                                        {\deduce{\Xref, \Yref : \Set}{\gammaA : \SPAp}
                                         & \quad \deduce{\introA : \ArgA(\gammaA, \A, \B) \to \A}
                                                        {\deduce{\B : \A \to \Set}{\A : \Set}}
                                         & \quad \deduce{\repB: (x : \Yref) \to \B(\repIndex(x))}
                                                        {\deduce{\repIndex : \Yref \to \A}
                                                                {\repA : \Xref \to \A}}
                                         & \quad \gamma : \SPB(\Xref, \Yref, \gammaA)}
}
\]
%
Once again, the definition is simpler for codes in $\SPBp(\gammaA)$:
\[
\ArgBp(\gammaA, \A, \B, \introA, \gamma) \coloneqq
   \ArgB(\zero, \zero, \gammaA, \A, \B, \introA, \magic{\A}, \magic{\A}, \magic{\B \circ \magic{\A}}, \gamma)
\]
%
We define:
%todo: formatting
\begin{align*} 
&  \ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \nilB(a)) = \one \\
&  \ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \nonindB(K, \gamma)) \\  
&\quad= (x : K) \times \ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \gamma(x)) \\
&  \ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \AindB(K, \gamma)) \\
&\quad=  (j : K \to \A) \times \ArgB(\Xref + K, \Yref, \gammaA, \A, \B, \introA,  [\repA, j], \repIndex, \repB, \gamma) \\
&  \ArgB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \BindB(K, \hindex, \gamma)) \\
&\quad= (j : (x : K) \to \B((\repAbar(\gammaA, \introA, \repA, \repIndex, \repB) \circ \hindex)(x))) \times {} \\ 
& \qquad\quad     \ArgB(\Xref, \Yref + K, \gammaA, \A, \B, \introA, \repA, [\repIndex, \repAbar(\ldots) \circ \hindex], [\repB, j], \gamma)
\end{align*}

Finally, we need the function $\IndexBp(\ldots) : \ArgB(\gammaA, \gammaB, \A, \B,
\introA) \to \A$ which to each $b : \ArgB(\gammaA, \gammaB, \A, \B,
\introA)$ assigns an index $a : \A$ such that the element constructed
from $b$ is in $\B(a)$.
%
\[
\mathclap{%
\infer{\IndexB(\Xref, \Yref, \gammaA, \A, \B, \introA, \repA, \repIndex, \repB, \gamma) : \ArgB(\ldots) \to \A}
                                        {\deduce{\Xref, \Yref : \Set}{\gammaA : \SPAp}
                                         & \quad \deduce{\introA : \ArgA(\gammaA, \A, \B) \to \A}
                                                        {\deduce{\B : \A \to \Set}{\A : \Set}}
                                         & \quad \deduce{\repB: (x : \Yref) \to \B(\repIndex(x))}
                                                        {\deduce{\repIndex : \Yref \to \A}
                                                                {\repA : \Xref \to \A}}
                                         & \quad \gamma : \SPB(\Xref, \Yref, \gammaA)}
}
\]
%
As we usually do, we define $\IndexBp : \ArgBp(\gammaA, \A, \B,
\introA, \gammaB) \to \A$ by
$\IndexBp(\gammaA, \A, \B, \introA, \gammaB) \coloneqq
   \IndexB(\zero, \zero, \gammaA, \A, \B, \introA, \magic{\A}, \magic{\A}, \magic{\B \circ \magic{\A}}, \gammaB)$.

For the equations, we will suppress all inferable arguments:
%
\begin{align*} 
\IndexB(\ldots, \nilB(a), \oneelt) &= \repAbar(\ldots, a) \\
\IndexB(\ldots, \nonindB(K, \gamma), \pair{k}{y}) &= \IndexB(\ldots, \gamma(k), y) \\  
\IndexB(\ldots, \AindB(K, \gamma), \pair{j}{y})  &= \IndexB(\ldots, \gamma, y) \\
\IndexB(\ldots, \BindB(K, \hindex, \gamma), \pair{j}{y})  &= \IndexB(\ldots, \gamma, y)
\end{align*}

\begin{example} %todo
  The constructor $\Pi : \big((\Gamma : \Ctxt) \times (\sigma : \Ty(\Gamma))
  \times \Ty(\consCtxt{\Gamma}{\sigma})\big) \to \Ty(\Gamma)$ from Example
\ref{ex:ctxt-type} is represented by the code
%
\[
\gamma_{\Pi} = \AindB(\one, \BindB(\one, (\lambda \oneelt.\,\widehat{\Gamma}),\BindB(\one,
(\lambda \oneelt.\,\widehat{\consCtxt{\Gamma}{\sigma}}, \nilB(\widehat{\Gamma}))))) : \SPBp(\gamma_{\consCtxtbare}) \enspace ,
\]
  where $\widehat{\Gamma} = \termAref(\inr(\oneelt)) : \Aterm(\zero +
  \one, \zero, \gamma_{\consCtxtbare})$ and
  \[
  \widehat{\consCtxt{\Gamma}{\sigma}} = \termArg(\langle (\lambda
  \oneelt.\termBref(\inr(\oneelt))), \langle \lambda \oneelt.\oneelt,
  \oneelt\rangle\rangle) : \Aterm(\zero + \one, \zero + \one,
  \gamma_{\consCtxtbare}) \enspace .
  \]
%
We have 
\begin{multline*}
  \ArgBp(\gamma_{\consCtxtbare}, \Ctxt, \Ty, \consCtxtbare,
  \gamma_{\Pi}) = \\
 (\Gamma : \one \to \Ctxt) \times (\sigma : \one \to
  \Ty(\Gamma(\oneelt))) \times (\one \to
  \Ty(\consCtxt{\Gamma(\oneelt)}{\sigma(\oneelt)}) \times \one
\end{multline*}
and $\IndexBp(\gamma_{\consCtxtbare}, \Ctxt, \Ty, \consCtxtbare,
\gamma_{\Pi}, \langle \Gamma, \sigma, \tau, \oneelt\rangle) =
\Gamma(\oneelt)$.


%(and also $\widehat{\Gamma} : \Aterm({\zero + \one}, {\zero + \one + \one}, \gamma_{\Ctxt})$)

\blackqed
\end{example}

\subsubsection{Formation and introduction rules}
\label{sec:intro-elim}

We are now ready to give the formation and introduction rules for $A$
and $B$. They all have the common premises $\gammaA : \SPAp$, $\gammaB
: \SPBp(\gammaA)$, which will be omitted.

Formation rules:
%
\[
A_{\gammaAB} : \Set \qquad\quad
B_{\gammaAB} : A_{\gammaAB} \to \Set
\]
%
Introduction rule for $A_{\gammaAB}$:
%
\[ 
\infer{\intro{A_{\gammaAB}}(a) : A_{\gammaAB}}{a : \ArgAp(\gammaA, A_{\gammaAB}, B_{\gammaAB})}
\]
%
Introduction rule for $B_{\gammaAB}$:
%
\[
\infer{\intro{B_{\gammaAB}}(a) : B_{\gammaAB}(\IndexBp(\gammaA, A_{\gammaAB}, B_{\gammaAB}, \intro{A_{\gammaAB}}, \gammaB, a))}{a : \ArgBp(\gammaA, A_{\gammaAB}, B_{\gammaAB}, \intro{A_{\gammaAB}}, \gammaB)}
\]
%

Elimination rules can also be
formulated~\cite{nordvallforsbergAltenkirchMorrisSetzer2011catsemindind}. Here,
we just give the elimination rules for the data type of sorted lists
(Example~\ref{ex:sorted-list}) as an example, and show how one can use them to
define a function which inserts a number into a sorted list.

\begin{example}
  The elimination rules for sorted lists and the $\lessList$ predicate
  state that functions $\elim_{\SortedList}$ and $\elim_{\lessList}$
  with the following types exist:
  \begin{align*}
    \elim_{\SortedList} :\ & (P : \SortedList \to \Set) \to \\
                       & (Q : (n : \Nat) \to (\ell : \SortedList) \to n \lessList \ell \to P(\ell) \to \Set) \to \\
                       & (\stepind{\nilList} : P(\nilList)) \to \\
                       & \big(\stepind{\consListbare} : (n : \Nat) \to (\ell : \SortedList) \to (p : n \lessList \ell) \to (\stepindarg{\ell} : P(\ell)) \\
                       & \qquad \to Q(n, \ell, p, \stepindarg{\ell}) \to P(\consList{n}{\ell}{p})\big) \to \\
                       & \big(\stepind{\nilLess{}} : (m : \Nat) \to Q(m, \nilList, \nilLess{n}, \stepind{\nilList})\big) \to \\
                       & \big(\stepind{\consLessbare} : (m : \Nat) \to (n : \Nat) \to (\ell : \SortedList) \to (p : n \lessList \ell) \\
                       & \qquad \to (q : m \leq n) \to (p' : m \lessList \ell) \to
                       (\stepindarg{\ell} : P(\ell)) \\ 
                       & \qquad \to (\stepindarg{p} : Q(n, \ell,p, \stepindarg{\ell}))
                       \to (\stepindarg{p'} : Q(m, \ell, p', \stepindarg{\ell})) \\
                       & \qquad \to Q(m,\consList{n}{\ell}{p}, \consLess{m}{n}{\ell}{p}{q}{p'}, \stepind{\consListbare}(n, \ell, p, \stepindarg{\ell}, \stepindarg{p}))\big) \to \\
                       & (\ell : \SortedList) \to P(\ell) \enspace , \\
% 
     \elim_{\lessList} :\ & (P : \SortedList \to \Set) \to \\
                       & (Q : (n : \Nat) \to (\ell : \SortedList) \to n \lessList \ell \to P(\ell) \to \Set) \to \\
                       & (\stepind{\nilList} : \ldots) \to \\
                       & \big(\stepind{\consListbare} : \ldots\big) \to \\
                       & \big(\stepind{\nilLess{}} : \ldots\big) \to \\
                       & \big(\stepind{\consLessbare} : \ldots\big) \to \\
                       & (n : \Nat) \to (\ell : \SortedList) \to (p : n \lessList \ell) \\
                       & \qquad \to Q(n, \ell, p, \elim_{\SortedList}(\ldots, \ell)) \enspace .
  \end{align*}
with computation rules
%
\[
\elim_{\SortedList}(P, Q, \stepind{\nilList}, \stepind{\consListbare}, \stepind{\nilLess{}}, \stepind{\consLessbare}, \nilList) = \stepind{\nilList}
\]
and
\begin{multline*}
\elim_{\SortedList}(P, Q, \stepind{\nilList}, \stepind{\consListbare}, \stepind{\nilLess{}}, \stepind{\consLessbare}, \consList{n}{\ell}{p}) \\
= \stepind{\consListbare}(n, \ell, p, \elim_{\SortedList}(\ldots, \ell), 
\elim_{\lessList}(\ldots, n, \ell, p))  
\end{multline*}
%
for $\elim_{\SortedList}$, and
\[
\elim_{\lessList}(P, Q, \stepind{\nilList}, \stepind{\consListbare}, \stepind{\nilLess{}}, \stepind{\consLessbare}, m, \nilList, \nilLess{m}) = \stepind{\nilLess{}}(m)
\]
and
\begin{multline*}
\elim_{\lessList}(P, Q, \stepind{\nilList}, \stepind{\consListbare}, \stepind{\nilLess{}}, \stepind{\consLessbare}, m, \consList{n}{\ell}{p}, \consLess{m}{n}{\ell}{p}{q}{p'}) \\
= \stepind{\consLessbare}(m, n, \ell, p, q, p', \elim_{\SortedList}(\ldots, \ell), \\
\elim_{\lessList}(\ldots, n, \ell, p), \elim_{\lessList}(\ldots, m, \ell, p'))
\end{multline*}
for $\elim_{\lessList}$. Notice how the computation rules for
$\elim_{\lessList}$ are well-typed because of the computation rules
for $\elim_{\SortedList}$.

Now, suppose that we want to define a function $\Listinsert :
\SortedList \to \Nat \to \SortedList$ which inserts a number $m$ into
its appropriate place in a sorted list $\ell$ to create a new sorted
list. From a high-level perspective, this is easy: the elimination
rules allows us to make case distinctions between empty and non-empty
lists, so it suffices to handle these two cases separately. The empty
list is easy to handle, and for non-empty lists, we compare $m$ with
the first element $n$ of the list $\ell = [n, \ldots]$, which is
possible since $\leq$ on natural numbers is decidable. If $m \leq n$,
the result should be $[m, n, \ldots]$, otherwise we recursively insert
$m$ into the tail of the list.

In detail, we choose $P(\ell) = \Nat \to \SortedList$ and, in our
first attempt, $Q(n, \ell, p, \stepindarg{\ell}) = \one$, since we are
only interested in getting a function $\elim_{\SortedList}(\ldots) :
\SortedList \to \Nat \to \SortedList$. We need to give functions
$\stepind{\nilList} : (m : \Nat) \to \SortedList$ and $\stepind{\consListbare}(n, \ell, p) :
%(n : \Nat) \to (\ell : \SortedList) \to (p : n \lessList \ell) \to
(\stepindarg{\ell} : \Nat \to \SortedList) \to Q(n, \ell, p,
\stepindarg{\ell}) \to (m : \Nat) \to \SortedList$ to use when
inserting into the empty list $\nilList$ or the list
$\consList{n}{\ell}{p}$ respectively. The argument $\stepindarg{\ell}
: \Nat \to \SortedList$ gives the result of a recursive call on
$\ell$.

The function $\stepind{\nilList}$ is easy to define: it should be
\[
\stepind{\nilList}(m) = \consList{m}{\nilList}{\nilLess{m}}
\]
For $\stepind{\consListbare}$, the decidability of $\leq$ (combined
with the fact that $\leq$ is total) allows us to distinguish between
the cases when $m \leq n$ and $n \leq m$. We try:
\[
\stepind{\consListbare}(n, \ell, p, \stepindarg{\ell}, \oneelt, m) =
\begin{cases}
  \consList{m}{\consList{n}{\ell}{p}}{\consLess{m}{n}{\ell}{p}{q}{\lessListtrans{q}{p}}} & \text{where $q : m \leq n$} \\
  \consList{n}{\stepindarg{\ell}(m)}{\SHED} & \text{where $q : n \leq m$} 
\end{cases}
\]
Here, $\lessListtransbare : m \leq n \to n \lessList \ell \to m
\lessList \ell$ witnesses a kind of transitivity of $\leq$ and
$\lessList$. It can be straightforwardly defined with the elimination
rules. The question is what we should fill the hole $\SHED$ with. We
need to provide a proof that $n \lessList \stepindarg{l}(m)$, i.e.\
that $n \lessList \Listinsert(l, m)$ if we remember that
$\stepindarg{l}$ is the result of the recursive call on $\ell$. We
need to prove this simultaneously as we define $\Listinsert$!
Fortunately, this is exactly what the elimination rules allow us to do
if we choose a more meaningful $Q$.

Thus, we try again, but this time with 
\[
Q(n, \ell, p,\stepindarg{\ell})
   = (m : \Nat) \to n \leq m \to n \lessList \stepindarg{l}(m) \enspace .
\]
The argument $\oneelt : \one$ to $\stepind{\consListbare}$ in our
first attempt has now been replaced with the argument $\stepindarg{p}
: (m : \Nat) \to n \leq m \to n \lessList \stepindarg{l}(m)$, and we can define
\[
\stepind{\consListbare}(n, \ell, p, \stepindarg{\ell}, \stepindarg{p}, m) =
\begin{cases}
  \consList{m}{\consList{n}{\ell}{p}}{\consLess{m}{n}{\ell}{p}{q}{\lessListtrans{q}{p}}} & \text{where $q : m \leq n$} \\
  \consList{n}{\stepindarg{\ell}(m)}{\stepindarg{p}(m, q)} & \text{where $q : n \leq m$} 
\end{cases}
\]
%
Now we must also define $\stepind{\nilLess{}} : (n : \Nat) \to Q(n,
\nilList, \nilLess{n}, \stepind{\nilList})$ and
$\stepind{\consLessbare}$ with type as above for our choice of $P$ and
$Q$. This presents us with no further difficulties. For
$\stepind{\nilLess{}}$, expanding $Q(n, \nilList, \nilLess{n},
\stepind{\nilList})$ and replacing $\stepind{\nilLess{}}$ with its
definition, we see that we should give a function of type
\[
\stepind{\nilLess{}} : (n : \Nat) \to (m : \Nat) \to n \leq m \to n
\lessList \consList{m}{\nilList}{\nilLess{m}} \enspace ,
\]
so we can define $\stepind{\nilLess{}}(n, m, p) = {}
\consLess{n}{m}{\nilList}{\nilLess{m}}{p}{\nilLess{n}}$. The
definition of follows the pattern of $\stepind{\consListbare}$
above. Rather than trying to explain it, we just give the definition:
\[
\stepind{\consLessbare}(m, n, \ell, p, q, p', \stepindarg{\ell}, \stepindarg{p}, \stepindarg{p'}, x, r) =
\begin{cases}
  \consLess{m}{x}{\consList{n}{\ell}{p}}{\consLess{m}{n}{\ell}{p}{s}{\lessListtrans{s}{p}}}{r}{\consLess{m}{n}{\ell}{p}{q}{p'}} & \text{where $s : m \leq n$} \\
  \consLess{m}{n}{p'}{\stepindarg{p}(x, s)}{q}{\stepindarg{p'}(x, r)} & \text{where $s : n \leq m$} 
\end{cases}
\]
%
With all pieces in place, we can now define $\Listinsert : \SortedList
\to \Nat \to \SortedList$ as $\Listinsert = \elim_{\SortedList}(P, Q,
\stepind{\nilList}, \stepind{\consListbare}, \stepind{\nilLess{}},
\stepind{\consLessbare})$.
\blackqed

% P : SList -> Set
% P ys = (n : ℕ) -> SList

% Q : (y : ℕ) -> (ys : SList) -> y ≤L ys -> P ys -> Set
% Q y ys p insert[_,ys] = (x : ℕ) -> y ≤ x ->  y ≤L insert[_,ys] x

% step[] : P []
% step[] m = m :: [] 〈 triv

%step:: : (n : ℕ) -> (ys : SList) -> (p : n ≤L ys) -> (pp : P ys) -> Q n ys p pp 
%             -> P (n :: ys 〈 p)
%step:: n ys p insert[_,ys] lemma[_,ys,p] m with m ≤? n 
%... | yes q = m :: n :: ys 〈 p 〈 cons q (≤L-trans ys q p)
%... | no ¬q = n :: (insert[_,ys] m) 〈 lemma[_,ys,p] m (¬x<y→y<x ¬q)

% steptriv : (n : ℕ) -> Q n [] triv step[]
% steptriv y x y<x = cons y<x triv

% stepcons : (m : ℕ) -> {n : ℕ} -> {ys : SList} -> {p : n ≤L ys} -> 
%            (q : m ≤ n) -> (p' : m ≤L ys) ->
%            (pp : P ys) -> (qq : Q n ys p pp) -> (qqq : Q m ys p' pp)
%              -> Q m (n :: ys 〈 p) (cons {m} {n} {ys} {p} q p') (step:: n ys p pp qq)
% stepcons m {n} {ys} {p} q m<ys insert[_,ys] lemma[_,ys,p] lemma[_,ys,m<ys] x r with x ≤? n
% ... | yes q = cons r (cons q m<ys)
% ... | no ¬q = cons q (lemma[_,ys,m<ys] x r)
\end{example}

\subsection{The examples revisited}
\label{sec:examples-revisited}

We show how to find \gammaAB{} for some well-known sets, including the
examples in Section~\ref{sec:examples}.

\subsubsection{Encoding multiple constructors into one}
\label{sec:comb-constructors}

The theory we have presented assumes that both $A$ and $B$ have
exactly one constructor each. This is no limitation, as multiple
constructors can always be encoded into one by using non-inductive
arguments. Suppose that $\intro{0} : F_0(A, B) \to A$ and $\intro{1} :
F_1(A, B) \to A$ are two constructors for $A$. Then we can combine
them into one constructor
\[
\intro{0 + 1} : \big((i : \two) \times F_i(A, B)\big) \to A
\]
by defining $\intro{0 +1}(i, x) = \intro{i}(x)$.

If $\intro{0}$ is described by the code $\gamma_0$ and $\intro{1}$ by
$\gamma_1$, then $\intro{0 + 1}$ is described by the code
\[
\gamma_0 \plOP \gamma_1 \coloneqq
\nonindA(\two, \lambda x.\IF~x~\THEN~\gamma_0~\ELSE~\gamma_1) \enspace .
\]


\subsubsection{Examples of codes for inductive-inductive definitions}

\begin{description}
\item[Well-orderings] Ordinary inductive definitions can be
  interpreted as inductive-inductive definitions where we only care
  about the index set $A$ and not about the family $B : A \to \Set$. A
  canonical choice is to let $B$ have constructor $\introB : (x : A)
  \to B(x)$, which is described by the code $\gamma_{\text{dummy}} \coloneqq 
  \AindB(\one, \nilB(\termAref(\inr(\oneelt))))$.

  For every $A : \Set$, $B : A \to \Set$, let
  \[
  \gamma_{W(A, B)} \coloneqq \nonindA(A, \lambda x\,.\,\AindA(B(x),\nilA))
  \]
  and define $W(A, B) \coloneqq A_{\gamma_{W(A, B)},
    \gamma_{\text{dummy}}}$.  Then $W(A, B)$ has constructor
  \[
  \intro{W(A, B)} : \big((x : A) \times (B(x) \to W(A, B)) \times \one\big) \to W(A, B) \enspace .
  \]

\item[Finite sets] Indexed inductive definitions can also be
  interpreted as inductive-inductive definitions, namely those where
  the index set just is an isomorphic copy of a previously constructed
  set (i.e.\ with constructor $\introA : I \to A$ for some $I : \Set$).

  For the family $\Fin : \Nat \to \Set$ of finite sets, the index set
  is $\Nat$, so we define
  \[
  \gamma_A \coloneqq \nonindA(\Nat, \lambda n\,.\,\nilA) : \SPAp
  \]
  and
  \[
  \gamma_{\Fin} \coloneqq \gamma_{\finzeroBare} \plOP \gamma_{\finsuccBare} : \SPBp(\gammaA)
  \]
  where
  \begin{align*}
    \gamma_{\finzeroBare} &\coloneqq \nonindB(\Nat, \lambda n\,.\,\nilB(\termArg(\pair{n + 1}{\oneelt}))) \enspace ,\\
    \gamma_{\finsuccBare} &\coloneqq \nonindB(\Nat, \lambda n\,.\,\BindB(\one, (\lambda \oneelt . \termArg(\pair{n}{\oneelt})), \nilB(\termArg(\pair{n + 1}{\oneelt})))) \enspace .
  \end{align*} 

  Then $\intro{A_{\gamma_A, \gamma_{\Fin}}} : \Nat \times \one \to
  A_{\gamma_A, \gamma_{\Fin}}$ is one part of an isomorphism $\Nat
  \cong \Nat \times \one \cong A_{\gamma_A, \gamma_{\Fin}}$, and if we
  define $\Fin : \Nat \to \Set$ by $\Fin(n) = B_{\gamma_A,
    \gamma_{\Fin}}(\intro{A_{\gamma_A,
    \gamma_{\Fin}}}(\pair{n}{\oneelt}))$, then we can define
  constructors
  \begin{align*}
    \infer{\finzero{n} : \Fin(n + 1)}{n : \Nat} \qquad
\infer{\finsucc{n}{m} : \Fin(n + 1)}{n : \Nat & \quad m : \Fin(n)}
  \end{align*}
  by $\finzero{n} = \intro{B_{\gamma_A,
      \gamma_{\Fin}}}(\pair{\twott}{\pair{n}{\oneelt}})$ and
  \[
  \finsucc{n}{m} = \intro{B_{\gamma_A,
      \gamma_{\Fin}}}(\pair{\twoff}{\pair{n}{\pair{(\lambda
        \oneelt\,.\,m)}{\oneelt}}} \enspace .
  \]
% γℕ' : SPA ⊥
% γℕ' = nonind ℕ (λ n → nilA)

% γFin : SPB ⊥ ⊥ γℕ'
% γFin =     nonind ℕ (λ n → nilB (inn (suc n , _)))
%        +++ nonind ℕ (λ n → B-ind ⊤ (λ _ → inn (n , _)) (nilB (inn ((suc n) , _))))

% ℕ' : Set
% ℕ' = A γℕ' γFin

% i : ℕ -> ℕ'
% i n = introA (n , _)

% Fin : ℕ -> Set
% Fin n = B γℕ' γFin (i n)

% fz : (n : ℕ) -> Fin (suc n)
% fz n = introB (tt , (n , _))

% fsuc : (n : ℕ) -> Fin n -> Fin (suc n)
% fsuc n m = introB (ff , n , ((λ _ → m) , _))


\item[Contexts and types]

The codes for the contexts and types from Example \ref{ex:ctxt-type}: \vskip
0.2cm
\begin{tabular}{lcl}
$\gamma_{\Ctxt}$ &$=$& $\nilA \plOP \AindA(\one, \BindA(\one, (\lambda \oneelt .\,\inr(\oneelt)),
\nilA)) : \SPAp$ \\
$\gamma_{\baseTybare}$ &$=$& $\AindB(\one, \nilB(\termAref(\inr(\oneelt))))$ \\
$\gamma_{\Pi}$ &$=$& $\AindB(\one, \BindB(\one, (\lambda \oneelt.\,\termAref(\inr(\oneelt))),\BindB(\one,$ \\
&& \qquad\quad $(\lambda \oneelt.\termArg(\langle \twoff, \langle (\lambda
\oneelt.\termBref(\inr(\oneelt))),$ 
 $\langle \lambda \oneelt.\oneelt, \oneelt\rangle\rangle\rangle),$ \\
&& \qquad\qquad $\nilB(\termAref(\inr(\oneelt))))))$ \\
$\gamma_{\Ty}$ &$=$& $\gamma_{\baseTybare} \plOP \gamma_{\Pi} : \SPBp(\gamma_{\Ctxt})\enspace .$
\end{tabular}
\vskip 0.2cm \noindent
We have $\Ctxt = A_{\gamma_{\Ctxt}, \gamma_{\Ty}}$ and $\Ty =
B_{\gamma_{\Ctxt}, \gamma_{\Ty}}$
and we can define the usual constructors by
\vskip 0.2cm
\begin{tabular}{l@{\qquad\qquad}l}
  $\emptyCtxt : \Ctxt$ & $\baseTybare : (\Gamma : \Ctxt) \to \Ty(\Gamma)$ \\
  $\emptyCtxt = \intro{A_{\gamma_{\Ctxt}, \gamma_{\Ty}}}(\langle \twott, \oneelt\rangle)\enspace ,$ & $\baseTy{\Gamma} = \intro{B_{\gamma_{\Ctxt}, \gamma_{\Ty}}}(\langle \twott, \langle (\lambda \oneelt.\Gamma), \oneelt\rangle\rangle)\enspace ,$\\
\end{tabular}
\vskip 0.2cm
\begin{tabular}{l}
  $\consCtxtbare : (\Gamma : \Ctxt) \to \Ty(\Gamma) \to \Ctxt$ \\
  $\consCtxt{\Gamma}{\sigma} = \intro{A_{\gamma_{\Ctxt}, \gamma_{\Ty}}}(\langle \twoff, \langle (\lambda \oneelt.\Gamma), \langle (\lambda \oneelt.\sigma), \oneelt\rangle \rangle\rangle)$ \enspace ,\\
\end{tabular}
\vskip 0.2cm
\begin{tabular}{l}
$\Pi : (\Gamma : \Ctxt) \to (\sigma : \Ty(\Gamma)) \to \Ty(\consCtxt{\Gamma}{\sigma}) \to
\Ty(\Gamma)$ \\
$\Pi(\Gamma, \sigma, \tau) = \intro{B_{\gamma_{\Ctxt}, \gamma_{\Ty}}}(\langle \twoff, \langle (\lambda
    \oneelt.\Gamma), \langle (\lambda \oneelt.\sigma),\langle (\lambda \oneelt. \tau) , \oneelt\rangle\rangle \rangle\rangle)$\enspace .
\end{tabular}

% γCtxt : SPA ⊥
% γCtxt = nilA ++ A-ind ⊤ (B-ind ⊤ (λ _ → inr _) nilA)

% γTy : SPB ⊥ ⊥ γCtxt
% γTy = A-ind ⊤ (nilB  (aref (inr _))) +++
%       A-ind ⊤ (B-ind ⊤  (λ _ → aref (inr _)) (B-ind ⊤ (λ _ → arg  (ff , ((λ _ → bref (inr _)) , ((λ _ → _) , _)))) (nilB  (aref (inr _)))))


% Ctxt : Set
% Ctxt = A γCtxt γTy

% Ty : Ctxt -> Set
% Ty = B γCtxt γTy


% ε : Ctxt
% ε = introA (tt , _)

% cons : (Γ : Ctxt) -> Ty Γ -> Ctxt
% cons Γ σ = introA ((ff , (λ _ → Γ) , (λ _ → σ) , _))

% ι : {Γ : Ctxt} -> Ty Γ
% ι {Γ} = introB ((tt , (λ _ → Γ) , _))

% Π : (Γ : Ctxt) -> (A : Ty Γ) -> (B : Ty (cons Γ A)) -> Ty Γ
% Π Γ A B = introB (ff , ((λ _ → Γ ) , ((λ _ → A) , ((λ _ → B) , _))))

%\item[Sorted lists] 
\end{description}

\section{A set-theoretic model}
\label{sec:model}

%todo: rewrite from CSL article

Even though $\SPA$ and $\SPB$ themselves are straightforward (large)
inductive definitions, this axiomatisation does not reduce
inductive-inductive definitions to indexed inductive definitions,
since the formation and introduction rules are not instances of
ordinary indexed inductive definitions.  (However, we do believe that
the theory of inductive-inductive definitions \emph{can} be reduced to
the theory of indexed inductive definitions with a bit of more
work.) %and plan to publish an article about this in the future.
%see Section~\ref{sec:indexed-induction}.)
To make sure that our theory is consistent, it is thus necessary to
construct a model.


We will develop a model in ZFC set theory, extended by two
inaccessible cardinals in order to interpret $\Set$ and $\TYPE$.  Our
model will be a simpler version of the models developed in
\cite{dybjersetzer1999finax,dybjersetzer2006IIR}. %Hence the proof theoretical
%strength required is, as expected significantly lower but still too
%strong. 
See Aczel \cite{aczel1999typesandsets} for a more detailed treatment
of interpreting type theory in set theory.



\subsection{Preliminaries}

We will be working informally in ZFC extended with the existence of two
strongly inaccessible cardinals $\cardz < \cardi$,
and will be using standard set theoretic constructions, e.g.
\begin{align*}
\langle a, b\rangle &\coloneqq \{ \{ a \}, \{ a, b \}\}, \\
\lambda x \in a.b(x) &\coloneqq \{\langle x, b(x)\rangle | x \in a \} \\
\Pi_{x \in a}b(x) &\coloneqq \{ f : a \to \bigcup_{x \in a}b(x)\ |\ \forall x \in a.f(x) \in b(x)\}, \\
\Sigma_{x \in a}b(x) &\coloneqq \{ \langle c , d\rangle\ |\ c \in a \land d
\in b(c) \}, \\
0 &\coloneqq \emptyset, 1 \coloneqq \{0\}, 2 \coloneqq \{0, 1\}, \\
%\Nat &\coloneqq \text{smallest set containing $0$ and closed under successor} \\
a_0 + \ldots + a_n &\coloneqq \Sigma_{i \in \{0, \ldots, n\}}a_i
\end{align*}
and the cumulative hierarchy $V_{\alpha} \coloneqq
\displaystyle\bigcup_{\beta < \alpha} \mathcal{P}(V_{\beta})$. Whenever we
introduce sets $A^{\alpha}$ indexed by ordinals $\alpha$, let \[A^{< \alpha}
\coloneqq \displaystyle\bigcup_{\beta < \alpha}A^{\beta}.\]

For every expression $A$ of our type theory, we will give an interpretation
$\sem{A}_\rho$, regardless if $A : \TYPE$ or $A : B$ or not. Interpretations
might however be undefined, written $\sem{A}_\rho\uparrow$. If $\sem{A}_\rho$
is defined, we write $\sem{A}_\rho\downarrow$. We write $A \simeq B$ for
partial equality, i.e.\ $A \simeq B$ if and only if $A\downarrow
\Leftrightarrow B\downarrow$ and if $A\downarrow$, then $A = B$. We write $A
\colonsimeq B$ if we define $A$ such that $A \simeq B$.

Open terms will be interpreted relative to an environment $\rho$, i.e.\ a
function mapping variables to terms. Write \rhoextend{x}{a} for the
environment $\rho$ extended with $x \mapsto a$, i.e.\ $\rhoextend{x}{a}(y) = a$
if $y = x$ and $\rho(y)$ otherwise. The interpretation $\sem{t}_{\rho}$ of closed
terms $t$ will not depend on the environment, and we omit the subscript $\rho$.

\subsection{Interpretation of Expressions}
\noindent 
The interpretation of the logical framework is as in
\cite{dybjersetzer1999finax}:
\begin{gather*}
\sem{\Set} \colonsimeq V_{\cardz} \qquad \sem{\TYPE} \colonsimeq V_{\cardi} \\
\sem{(x : A) \to B}_\rho \colonsimeq \Pi_{y \in
  \sem{A}_\rho}\sem{B}_{\rhoextend{y}{x}} \qquad
\sem{\lambda x:A.e}_\rho \colonsimeq \lambda y \in
\sem{A}_\rho.\sem{e}_{\rhoextend{y}{x}} \\
\sem{(x : A) \times B}_\rho \colonsimeq \Sigma_{y \in
  \sem{A}_\rho}\sem{B}_{\rhoextend{y}{x}} \qquad
\sem{\langle a, b \rangle}_\rho \colonsimeq \langle \sem{a}_\rho ,
\sem{b}_\rho\rangle \\
\sem{\zero} \colonsimeq 0 \qquad \sem{\one} \colonsimeq 1 \qquad
\sem{\two} \colonsimeq 2 \qquad \sem{\oneelt} \colonsimeq 0 \qquad \sem{\twott} \colonsimeq 0 \qquad
\sem{\twoff} \colonsimeq 1\\
\sem{\IF~x~\THEN~a~\ELSE~b}_\rho \colonsimeq
\begin{cases}
\sem{a}_\rho & \text{if $\sem{x}_\rho = 0$} \\
\sem{b}_\rho & \text{if $\sem{x}_\rho = 1$} \\
\text{undefined} & \text{otherwise} \\
\end{cases} \\
\sem{!_A}_\rho \colonsimeq \text{unique inclusion $\iota_{\sem{A}} : \emptyset \to \sem{A}_\rho$ }
\end{gather*}

To interpret terms containing $\SPA$, $\SPB$, $\ArgA$, $\ArgB$, $\IndexB$, 
$\nilA$, $\nonindA$, $\AindA$, $\BindA$, we first define $\sem{\SPA}$,
$\sem{\SPB}$, $\sem{\ArgA}$, $\sem{\nilA}$, $\sem{\nonindA}$, \ldots and interpret
\begin{align*}
\sem{\SPA(\Xref)}_\rho &\coloneqq \sem{\SPA}(\sem{\Xref}_\rho) \\
\vdots \\
\sem{\ArgA(\Xref, \gamma, A, B, \repA)}_\rho &\coloneqq
\sem{\ArgA}(\sem{\Xref}_\rho, \sem{\gamma}_\rho, \sem{A}_\rho, \sem{B}_\rho, \sem{\repA}_\rho) \\
\vdots \\
\sem{\nonindA(K, \gamma)}_\rho &\coloneqq \sem{\nonindA}(\sem{K}_\rho,
\sem{\gamma}_\rho) \\
\vdots & \text{\quad etc.}
\end{align*}
In all future definitions, if we are currently defining $\sem{F}$ where $F : D
\to E$, say, let $F(d)\uparrow$ if $d \notin \sem{D}$.

$\sem{\SPA}(\Xref)$ is defined as the least set such that
\begin{align*}
\sem{\SPA}(\Xref) &= 1 + \sum_{K \in \sem{\Set}}(K \to \sem{\SPA}(\Xref))
  + \sum_{K \in \sem{\Set}}\sem{\SPA}(\Xref + K) \\
 & {} + \sum_{K \in \sem{\Set}}\sum_{h : K \to \Xref}\sem{\SPA}(\Xref).
\end{align*}
 By the inaccessibility of $\cardi$, there is a
regular cardinal ${\kappa < \cardi}$ such that for all $K \in \sem{\Set}$, we
have that the cardinality of $K$, $\Xref$, $\Xref + K$ and $(K \to \Xref)$ is less than
$\kappa$. If we now iterate an appropriate operator $\kappa$ times, we get our
solution, which must be an element of $\sem{\TYPE} = V_{\cardi}$ by the
inaccessibility of $\cardi$.
\begin{align*}
 \sem{\nilA} \colonsimeq \langle 0, 0\rangle \quad
 \sem{\BindA(K, h, \gamma)} \colonsimeq \langle 3 , \langle K, \langle h, \gamma \rangle\rangle\rangle
   \\
  \sem{\nonindA(K, \gamma)} \coloneqq \langle 1 , \langle K, \gamma
  \rangle\rangle \quad \sem{\AindA(K, \gamma)} \colonsimeq \langle 2 , \langle K, \gamma \rangle\rangle
\end{align*}
$\sem{\SPB}$ and its constructors are defined
analogously. $\sem{\ArgA}$, $\sem{\ArgB}$ and $\sem{\IndexB}$ are defined according to their equations,
e.g.\ 
\begin{align*}
  \sem{\ArgA}(\Xref, \sem{\nilA}, A, B, \repA) &\colonsimeq 1 \\
\sem{\ArgA}(\Xref, \sem{\nonindA}(K, \gamma), A. B. \repA) &\colonsimeq
  \sum_{k \in K} \sem{\ArgA}(\Xref, \gamma(k), A, B, \repA) \\
\sem{\ArgA}(\Xref, \sem{\AindA}(K, \gamma), A, B, \repA) &\colonsimeq
  \sum_{j : K \to A}\sem{\ArgA}(\Xref + K, \gamma, A, B, [\repA, j]) \\
\sem{\ArgA}(\Xref, \sem{\BindA}(K, h, \gamma), A, B, \repA) &\colonsimeq
  \sum_{\mathclap{j \in \Pi_{k \in K} B(\repA (h(k)))}}\sem{\ArgA}(\Xref, \gamma, A, B, \repA).
\end{align*}
%
% todo: rework to new axiomatisation
%

Finally, we have to interpret $A_{\gammaAB}$, $B_{\gammaAB}$,
$\intro{A_{\gammaAB}}$ and $\intro{B_{\gammaAB}}$.  The high-level
idea is to iterate $\ArgAp$ until a fixed point is reached, then apply
$\ArgBp$ once, and repeat. This is necessary since $\ArgBp$ expects an
argument $\introA : \ArgAp(\gammaA, A, B) \to A$, which can be chosen
to be the identity if $A$ is a fixed point of $\ArgAp(\gammaA, A, B)$
(with $B$ fixed). In more detail, let
\begin{gather*}
\sem{A_{\gammaAB}} \colonsimeq A^{\cardz} \enspace\! , \quad\!\!
\sem{B_{\gammaAB}}(a) \colonsimeq B^{\cardz}(a)\enspace\! , \quad\!\!
\sem{\intro{A_{\gammaAB}}}(a) \colonsimeq a \enspace\! ,\quad\!\!
\sem{\intro{B_{\gammaAB}}}(b) \colonsimeq b \enspace\! ,\\
\end{gather*} \vskip -0.5cm \noindent 
where $A^{\alpha}$ and $B^{\alpha}$ are
simultaneously defined by recursion on $\alpha$ as
\begin{align*}
  A^{\alpha} & \coloneqq  \text{least fixed point of }
       \lambda X\,.\, \sem{\ArgAp}(\gamma_A, A^{< \alpha} \cup X, [B^{< \alpha}, \lambda x\,.\,\emptyset]) \enspace ,\\
  B^{\alpha}(a) & \coloneqq \{b\ |\ b \in \sem{\ArgBp}(\gamma_A, A^{< \alpha} \cup A^{\alpha},
  [B^{< \alpha}, \lambda x\,.\,\emptyset], \id, \gamma_B) \\
  & \quad \land \sem{\IndexBp}(\gamma_A,
  A^{< \alpha} \cup A^{\alpha}, [B^{< \alpha}, \lambda x\,.\,\emptyset], \id, \gamma_B, b) = a \}\enspace \hspace{-2.47968pt} .
\end{align*}

The (graph of the) eliminators can then be built up in the same
stages.

Having interpreted all terms, we finally interpret contexts as sets of environments:
\begin{align*}
  \sem{\emptyset} \colonsimeq \emptyset && \sem{\Gamma, x : A} \colonsimeq \{
  \rhoextend{x}{a} \ |\ \rho \in \sem{\Gamma} \land a \in \sem{A}_\rho\}.
\end{align*}

\subsection{Soundness of the Rules}
\begin{theorem}[Soundness] \mbox{}
\label{thm:soundness}
  \begin{enumerate}[(i)]
  \item If ${} \tstile \Gamma \text{context}$, then
    $\sem{\Gamma}\downarrow$. 
  \item If $\Gamma \tstile A : E$, then $\sem{\Gamma}\downarrow$, and
    for all $\rho \in \sem{\Gamma}$, ${\sem{A}_\rho \in \sem{E}_\rho}$, and also
    $\sem{E}_\rho \in \sem{\TYPE}$ if $E \not\equiv \TYPE$.
  \item If $\Gamma \tstile A = B : E$, then $\sem{\Gamma}\downarrow$, and
    for all $\rho \in \sem{\Gamma}$, $\sem{A}_\rho = \sem{B}_\rho$,
    $\sem{A}_\rho \in \sem{E}_\rho$ and also $\sem{E}_\rho \in \sem{\TYPE}$ if
    $E \not\equiv \TYPE$. 
  \item $\nvdash a : \zero$. \qed
  \end{enumerate}
\end{theorem}
The proof of the soundness theorem is rather
  straight\-forward. For the verification that $\sem{A_{\gamma_A, \gamma_B}}
  \in \sem{\Set}$ and $\sem{B_{\gamma_A, \gamma_B}} : \sem{A_{\gamma_A,
      \gamma_B}} \to \sem{\Set}$, one first verifies that $\sem{\ArgAp}$,
  $\sem{\ArgBp}$, $\sem{\IndexBp}$ are monotone in the following sense:
  %
  \begin{lemma}
  \label{thm:Arg-monotone}
  For all $\gammaA \in \sem{\SPAp}$ and $\gammaB \in \sem{\SPBp}(\gammaA)$:
  \begin{enumerate}[(i)]
  \item If $A \subseteq A'$ and $B(x) \subseteq B'(x)$ then
    $\sem{\ArgAp}(\gammaA, A, B) \subseteq \sem{\ArgAp}(\gammaA, A', B')$.
  \item If in addition $\introA(x) = \introA'(x)$ for all $x \in \ArgAp(\gammaA, A, B)$, then
    \[
    \sem{\ArgBp}(\gammaA, A, B, \introA, \gammaB) \subseteq \sem{\ArgBp}(\gammaA, A', B', \introA', \gammaB)
    \]
    and
    \[    
    \sem{\IndexBp}(\gammaA, A, B, \introA, \gammaB, x) = \sem{\IndexBp}(\gammaA, A', B', \introA', \gammaB, x)
    \]
    for all $x \in \sem{\ArgBp}(\gammaA, A, B, \introA, \gammaB)$. \qed
  \end{enumerate}
  \end{lemma}

One can then prove some useful facts about $A^{\alpha}$ and
  $B^{\alpha}$: % by induction on $\alpha$:
\begin{lemma} \mbox{}
\label{thm:A-in-Set}
  \begin{enumerate}[(i)]
  \item For $\alpha < \cardz$, $A^{\alpha} \in \sem{\Set}$ and $B^{\alpha} :
    A^{\alpha} \to \sem{\Set}$.
  \item For $\alpha < \beta$, $A^{\alpha} \subseteq A^{\beta}$ and  $B^{\alpha}(a) \subseteq
    B^{\beta}(a)$ for all $a \in A^{\alpha}$. 
  \item There is $\kappa < \cardz$ such that for  all $\alpha \geq \kappa$,
    $A^{\alpha} = A^{\kappa}$ and $B^{\alpha}(a) =  B^{\kappa}(a)$ for all $a
    \in A^{\alpha}$. \qed 
  \end{enumerate}
\end{lemma}
\begin{proof}
  \begin{enumerate}[(i)]
  \item Induction over $\alpha$.

\notIncludedProof{  %todo
  \begin{itemize}
  \item If $\alpha = 0$, then $A^{\alpha} =  \text{least fixed point of }
       \lambda X\,.\, \sem{\ArgAp}(\gamma_A, X, \lambda x\,.\,\emptyset)$.
 % \item If $\alpha = \beta + 1$
 % \item If $\alpha = \lambda$ limit
  \end{itemize}
}
  \item Induction over $\alpha$. %todo
  \item Let $\kappa$ be a regular cardinal of cardinality greater than
    that of all index sets which starts an inductive argument. By the
    inaccessibility of $\cardz$, $\kappa < \cardz$.  %todo
\qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}
  $\sem{A_{\gamma_A, \gamma_B}} \in \sem{\Set}$ and $\sem{B_{\gamma_A,
      \gamma_B}} : \sem{A_{\gamma_A, \gamma_B}} \to \sem{\Set}$.
\end{theorem}
\begin{proof}
  By Lemma~\ref{thm:A-in-Set}, $\sem{A_{\gamma_A, \gamma_B}} = A^{\cardz} = A^{\kappa} \in
  \sem{\Set}$,  and similarly for $\sem{B_{\gamma_A, \gamma_B}}$. \qedhere
\end{proof}



 %\section{Remarks} %todo: better title
 %\label{sec:remarks}

% \subsection{The r\^{o}le of large elimination}
% \label{sec:large-elim}



%\subsection{Indexed inductive definitions and induction-induction}
%\label{sec:indexed-induction}



%\section{Conclusions}
%\label{sec:conclusions}

\bibliographystyle{alpha}
\bibliography{biblio}


\end{document}

